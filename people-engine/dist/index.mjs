var t={fetch:async(t,e)=>await async function(t,e){try{const s=t.headers.get("Upgrade");if(!s||"websocket"!==s)return new Response("Expected Upgrade: websocket",{status:426});let i=e.PEOPLE.idFromName("Meeting Hall"),a=e.PEOPLE.get(i);return await a.fetch(t)}catch(t){return new Response(t.message,{status:200})}}(t,e)};class e{constructor(t,e){this.state=t,this.people={},this.structures={},this.state.blockConcurrencyWhile((async()=>{let t=await this.state.storage.get("structures");this.structures=t||{};let e=await this.state.storage.get("sessions");this.sessions=e||[];let s=await this.state.storage.get("people");this.people=s||{}}))}async fetch(t){const e=new WebSocketPair,[s,i]=Object.values(e);let a=i;a.accept();let r={webSocket:a},n=!1;this.sessions.push(r),a.addEventListener("message",(async t=>{if(r.quit)return a.close(1011,"WebSocket broken."),void delete this.people[r.uid];let e=JSON.parse(t.data);if(e.update_position&&(this.people[e.update_position.uid].position=e.update_position.position,this.broadcast(JSON.stringify(e))),e.build_structure){let t={uid:e.build_structure.uid,player:e.build_structure.player_uid,pos:e.build_structure.pos};this.structures[t.uid]=t,this.broadcast(JSON.stringify({add_structure:t}),t.player_uid)}if(!n)return r.name=""+(e.name||"anonymous"),r.uid=e.uid,e.position||(e.position={x:50,y:50}),this.people[e.uid]=e,this.broadcast(JSON.stringify({joined:e})),a.send(JSON.stringify({people:this.people})),a.send(JSON.stringify({structures:this.structures})),n=!0,new Response(null,{status:101,webSocket:s});e={name:r.name,message:""+e.message},e.timestamp=Math.max(Date.now(),this.lastTimestamp+1),this.lastTimestamp=e.timestamp;let i=JSON.stringify(e);this.broadcast(i)}));let o=t=>{r.quit=!0,this.sessions=this.sessions.filter((t=>t!==r)),r.name&&(this.broadcast(JSON.stringify({quit:r})),delete this.people[r.uid])};return a.addEventListener("close",o),a.addEventListener("error",o),new Response(null,{status:101,webSocket:s})}broadcast(t,e=!1){"string"!=typeof t&&(t=JSON.stringify(t));let s=[];this.sessions=this.sessions.filter((i=>{try{return e&&i.uid,i.webSocket.send(t),!0}catch(t){return i.quit=!0,s.push(i),!1}})),s.forEach((t=>{this.broadcast({quit:t})}))}}export{e as People,t as default};
//# sourceMappingURL=index.mjs.map
